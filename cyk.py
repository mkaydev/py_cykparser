#!/usr/bin/python
import argparse
import collections
import itertools
import operator

class GrammarRule(collections.namedtuple("Rule", ["probability", "producer", "produced"])):
    __slots__ = ()

    def is_unary(self):
        return len(self.produced) == 1
    
    def __str__(self):
        printable = "{}: {} ->".format(self.probability, self.producer)
        printable += "".join(" {}".format(r) for r in self.produced)
        return printable


class Grammar:
    def __init__(self, nt_rules_file_name, t_rules_file_name, start_symbol):
        self.t_rules = self._read_rules(t_rules_file_name)
        self.nt_rules = self._read_rules(nt_rules_file_name)
        self.rules = self.t_rules.union(self.nt_rules)
        self.start_symbol = start_symbol
        self._substitute_cache = {}

    @staticmethod  
    def _read_rules(file_name):
        rules = set()
        with open(file_name, "r") as fh:
            for line in fh:
                probability, producer, *produced = line.strip().split()
                rules.add(GrammarRule(float(probability), producer, tuple(produced)))
        return rules

    def get_creating_rules(self, produced):
        return [rule for rule in self.rules if rule.produced == produced]

    def get_created_by_rules(self, producer):
        return [rule for rule in self.rules if rule.producer == producer]

    def get_substitute_rules(self, symbol):
        if not symbol in self._substitute_cache:
            self._substitute_cache[symbol] = tuple([
                rule for rule in self.nt_rules if rule.is_unary() and rule.produced == (symbol,)
            ])
        return self._substitute_cache[symbol]        

    def __str__(self):
        return "".join("{}\n".format(rule) for rule in self.nt_rules) + \
               "".join("{}\n".format(rule) for rule in self.t_rules)


class ParseTree(collections.namedtuple("SentenceParseNode", ["rule", "left", "right"])):
    __slots__ = ()

    @property
    def probability(self):
        if self.left is None: # terminal
            return self.rule.probability
        elif self.right is None: # unary
            return self.left.probability * self.rule.probability
        else:
            return self.left.probability * self.right.probability * self.rule.probability

    @property
    def producer(self):
        return self.rule.producer

    @property
    def produced(self):
        return self.rule.produced

    def _to_string(self, depth):
        next_depth = depth + 1
        
        if (self.left is None): # terminal
            return "({} {})".format(self.producer, self.produced[0])
        
        elif (self.right is None): # unary
            return "({}\t{})".format(self.producer, self.left._to_string(next_depth))
        
        else:
            return "({}\t{}\n{}{})".format(
                self.producer, self.left._to_string(next_depth), next_depth * "\t", self.right._to_string(next_depth)
            )
        
    def __str__(self):
        return self._to_string(depth=0)
    
        
class CYKParser:
    def __init__(self, nt_rules_file_name, t_rules_file_name, start_symbol):
        self.grammar = Grammar(nt_rules_file_name, t_rules_file_name, start_symbol)

    def get_parse_trees(self, sentences_file_name):
        sentences = self._read_sentences(sentences_file_name)
        result = []
        
        for sentence in sentences:            
            parse_trees = self.get_sentence_parse_trees(sentence)
            parse_trees.sort(key=operator.attrgetter("probability"), reverse=True)
            result += parse_trees
        return result

    def get_sentence_parse_trees(self, sentence):
        word_list = sentence.split()
        matrix = self._initialize_matrix_with_first_line(word_list)

        # parsing moves from diagonal to row, col = -1, 0
        for i in range(0, len(word_list) - 1):
            for j in range(1, len(word_list) - i):
                col = j - 1
                row = i + j
                matrix[row][col] = self._calculate_matrix_element(matrix, row, col)

        # if sentence can be generated by the grammar, there will be parse trees with start_symbol as producer in field row, col = -1, 0
        candidates = matrix[-1][0]
        return [parse_tree for parse_tree in candidates if parse_tree.producer == self.grammar.start_symbol]
                
    @staticmethod
    def _initialize_matrix(word_count):
        matrix = []
        for row_i in range(word_count):
            matrix_line = []

            # only need half matrix
            for col_i in range(0, row_i + 1):
                matrix_line.append(None)
            matrix.append(matrix_line)        
        return matrix

    def _initialize_matrix_with_first_line(self, word_list):
        word_count = len(word_list)
        matrix = self._initialize_matrix(word_count)
        
        for i in range(word_count):
            creating_rules = self.grammar.get_creating_rules((word_list[i],))
            tree_roots = [ParseTree(rule, None, None) for rule in creating_rules]
            matrix[i][i] = tree_roots
        return matrix

    def _calculate_matrix_element(self, matrix, row, col):
        leafs = set()
        
        for i in range(row - col, 0, -1):
            unsubstituted_roots1 = matrix[row - i][col]
            unsubstituted_roots2 = matrix[row][row - i + 1]

            #unary rules allow for substitution of non-terminals -> expand if possible
            substituted_roots1 = self._expand_with_substitutions(unsubstituted_roots1)
            substituted_roots2 = self._expand_with_substitutions(unsubstituted_roots2)

            for tree_roots_to_produce in itertools.product(substituted_roots1, substituted_roots2):
                leafs.add(tree_roots_to_produce)

        new_roots = set()
        for tree_roots_to_produce in leafs:
            needed_symbols = tuple(root.producer for root in tree_roots_to_produce)
            producing_rules = self.grammar.get_creating_rules(needed_symbols)
            
            for producing_rule in producing_rules:
                left = tree_roots_to_produce[0]
                right = tree_roots_to_produce[1]
                new_root = ParseTree(producing_rule, left, right)
                new_roots.add(new_root)
        
        return new_roots

    def _expand_with_substitutions(self, roots):
        result = set()
        for root in roots:
            result.add(root)
            root_symbol = root.producer

            substitute_rules = self.grammar.get_substitute_rules(root_symbol)
            for substitute_rule in substitute_rules:
                new_root = ParseTree(substitute_rule, root, None)
                result.add(new_root)

        return result

    @staticmethod    
    def _read_sentences(file_name):
        with open(file_name, "r") as fh:
            sentences = [line.strip() for line in fh]
        return sentences

    @staticmethod
    def _print_matrix(matrix):
        printable = ""

        for row in matrix:
            printable += "\n"
        
            for col in row:
            
                if col is None:
                    printable += str(col) + 4 * "\t"
                    continue
            
                printable += "["
                nt_set = set(tree.producer for tree in col)
                
                for i, producer in enumerate(nt_set):
                    printable += producer
                
                    if i < len(nt_set) - 1:
                        printable += ", "
                printable += "]\t"
        print(printable)

   
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Script which implements the Cocke-Younger-Kasami parsing algorithm with probabilistic rules.')
    parser.add_argument('--nt_rules', action="store", dest="nt_rules", default="NT_RULES", type=str, help="name of file with non-terminating rules")
    parser.add_argument('--t_rules', action="store", dest="t_rules", default="T_RULES", type=str, help="name of file with terminating rules of form")
    parser.add_argument('--output', action="store", dest="output", type=str, help="name of output-file (prints to stdout if not specified)")
    parser.add_argument('--start_symbol', action="store", dest="start_symbol", default="S", type=str, help="Start-symbol in Grammar") 
    parser.add_argument('--sentences', action="store", dest="sentences", default="SENTENCES", type=str, help="name of file with sentences (new line after each sentence)")
    args = parser.parse_args()

    parser = CYKParser(args.nt_rules, args.t_rules, args.start_symbol)
    parse_trees = parser.get_parse_trees(args.sentences)
    output_str = "".join("{}\n\n".format(tree) for tree in parse_trees)

    if args.output is None:
        print(output_str)
    else:
        with open(args.output, "w") as fh:
            fh.write(output_str)
